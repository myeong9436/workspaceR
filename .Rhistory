print ( var5 )
class ( number ); str( number )
class ( string ); str ( string )
class ( boolean ); str ( boolean )
class ( temp ); str ( temp )
is.numeric ( number )
is.numeric ( chanum )
is.character( number )
is.character( chanum )
result <-  number + as.numeric( chanum )
class( result ); str ( result )
print ( result )
x <-  c ( 1, 2, 3 )
y <-  c ( 4, 5, 6 )
x + y
x * y
z <-  x + y
z
v <-  c (1:10)
sum ( v )                  # 합계
sum ( 2 * v )
mean ( v )                 # 평균
mean ( v[ 1:5] )
median ( v )               # 중앙값
median ( v [ 1:5] )
max ( v )
min ( v )
sort ( v )                 # 정렬
sort ( v, decreaseing = FALSE )
sort ( v, decreaseing = TRUE )
range ( v )                # 값의범위(최소값~ 최대값)
var ( v )                  # 분산
sd ( v )                   # 표준편차
avg <-  sum ( v ) / length ( v )
avg
v <-  c (1:10)
sum ( v )                  # 합계
sum ( 2 * v )
mean ( v )                 # 평균
mean ( v[ 1:5] )
median ( v )               # 중앙값
median ( v [ 1:5] )
max ( v )
min ( v )
sort ( v )                 # 정렬
sort ( v, decreasing = FALSE )
sort ( v, decreasing = TRUE )
range ( v )                # 값의범위(최소값~ 최대값)
var ( v )                  # 분산
sd ( v )                   # 표준편차
avg <-  sum ( v ) / length ( v )
avg
number1 <-  10
number2 <-  19
number3 <-  3
# 관계 연산자 이용한 관계 연산
number1 > number2
number1 <= number2
# 관계/ 논리 연산자 이용한 논리 연산
# 논리연산 : and
(number1 > number2 ) && ( number1 > number2 )
# 논리연산 : or
(number1 > number2 ) || ( number1 > number2 )
v <-  1:10
v >= 5
v[ v > 5 ]
sum ( v > 5 )
v == 5
condition <- v > 5 & v > 8
condition
v[ condition ]
v <-  1:10
v >= 5
v[ v > 5 ]
sum ( v > 5 )
v == 5
condition <- v > 5 & v < 8
condition
v[ condition ]
vector_tc <-  c( 1, 2, TRUE, FALSE )
class ( vector_tc )
str ( vector_tc )
vector_tc
v <-  1:10
v >= 5
v[ v > 5 ]
sum ( v > 5 )
v == 5
condition <- v > 5 & v < 8
condition
v [ condition ]
abs( mean( d2 ) - mean( d1 ) )
d1 <- 1:50
d2 <- 51:100
#1. d1, d2값 출력
d1
d2
#2. d2 길이 출력
length( d2 )
#3. d1 + d2, d2 - d1, d1 * d2, d2 / d1의 결과 출력
d1 + d2
d2 - d1
d1 * d2
d2 / d1
#4. d1, d2 각각의 합 출력
sum( d1 )
sum( d2 )
#5. d1, d2의 모든 값들의 합 출력
sum( c( d1, d2 ) )                # 방법 1
sum( d1 ) + sum( d2 )             # 방법 2
#6. d2 최대값, 최소값 출력
max( d2 )
min( d2 )
#7. d2, d1의 각각의 평균값을 구한 후 평균과의 차이 출력
abs( mean( d2 ) - mean( d1 ) )
d3 <- c( sort( d1 )[ 1:10 ], sort( d2 )[ 1:10 ] )
d3
v1 <- 51:90
#1. 60보다 작은 수 모두 출력
v1[ v1 < 60 ]
#2. 70보다 작은 수가 몇 개인지 출력
length( v1[ v1 < 70 ] )
vl <-  51:90
# 60보다 작은수 출력
vl [ vl < 60 ]
length(vl < 70 )
length( [vl < 70] )
length( vl [vl < 70] )
v1 <- 51:90
v1 <- v1[ v1 %% 7 != 0 ]
v1
v1[ v1 %% 2 == 0 ] <- v1[ v1 %% 2 == 0 ] * 2
v1
sum( v1[ v1 > 65 ] )
number1 <-  10
number2 <-  19
number3 <-  3
# 관계 연산자 이용한 관계 연산
number1 > number2
number1 <= number2
# 관계/ 논리 연산자 이용한 논리 연산
# 논리연산 : and
(number1 > number2 ) && ( number1 > number3 )
# 논리연산 : or
(number1 > number2 ) || ( number1 > number3 )
v >= 5
v[ v > 5 ]
sum ( v > 5 )
v == 5
condition <- v > 5 & v < 8
condition
v [ condition ]
v1[ v1 > 60 & v1 < 73 ]
vl[ 60 < vl <73 ]
vl[ 60 < vl < 73 ]
v1[ v1 > 65 | v1 > 80 ]
v1[ v1 %% 7 == 0 ] <- 0
v1
v1[ v1 %% 7 == 0 ] <- 0
v1
v1 <- 51:90
d1 <- 1:50
d2 <- 51:100
#1. d1, d2값 출력
d1
d2
c( d1, d2 )
abs( mean( d2 ) - mean( d1 ) )
( mean( d2 ) - mean( d1 ) )
sort( d1, increasing = FALSE )
s1 <- sort ( d1 )
s2 <- sort ( d2 )
sort( d1, decreasing = TRUE )
d3 <- c( sort( d1 )[ 1:10 ], sort( d2 )[ 1:10 ] )
d3
s1 <- sort ( d1 )
s2 <- sort ( d2 )
s1 <- sort ( d1 )
s2 <- sort ( d2 )
s1 [1:10]
s2 [1:10]
result <-  c( s1[1:10], s2[1:10] )
result
vl[ 60 < vl < 73 ]
v1[ v1 > 65 | v1 > 80 ]
v1[ v1 %% 7 == 3 ]
#7. 7의 배수들의 값을 0으로 변경
v1[ v1 %% 7 == 0 ] <- 0
v1
v1 <- 51:90
#8. 짝수를 모두 합한 값을 출력
sum( v1[ v1 %% 2 == 0 ] )
#9. 홀수이거나 80보다 큰 수를 모두 출력
v1[ v1 %% 2 == 1 | v1 > 80 ]
#10. 3과 5의 공배수 출력
v1[ v1 %% 3 == 0 & v1 %% 5 == 0 ]
#11. 짝수에 대해서만 2를 곱해서 저장
v1[ v1 %% 2 == 0 ] <- v1[ v1 %% 2 == 0 ] * 2
v1
#12. 7의 배수들을 제거한 후 v1 내용 출력
v1 <- 51:90
v1 <- v1[ v1 %% 7 != 0 ]
v1
v1[ v1 < 65 | v1 > 80 ]
vt <-  c(TRUE, FALSE)
vt2 <- C( TRUE, FALSE)
vt & vt2
vt && vt2
vt <-  c( TRUE, FALSE )
vt2 <- c( TRUE, FALSE )
vt & vt2
vt && vt2
vt <-  c( FALSE, TRUE )
vt2 <- c( TRUE, FALSE )
vt & vt2 # 백터요소 각각에 대하여 and 연산 수행
vt && vt2 # 백터 첫번쨰 요소에 대하여 and 연산 수행
vl[ 60 < vl < 73 ]
v1[ v1 < 65 & v1 > 80 ]
v1 %% 7 == 3
v1[ v1 %% 7 == 3 ]
v1[ v1 %% 7 == 0 ] <- 0
v1
v1 <- 51:90
m <- c(10,40,60,20)
f <- c(21,60,70,30)
score <- data.frame(m,f)
score
score[ 2, ]
st <- data.frame(state.x77)
st
colnames( st )
names( st )
nrow( st )
ncol( st )
dim( st )
rowSums( st )
apply( st, 1, sum )
rowMeans( st )
apply( st, 1, mean )
st[ 'Florida', ]
#10. 50개 주의 수입(Income) 정보만 출력
st[ , 'Income' ]
#11. Texas 주의 면적(Area)을 출력
st[ 'Texas', 'Area' ]
score[ 2, ]
tmp <- subset( st, Illiteracy >= 2.0 )
tmp <- tmp$Income
mean( tmp )
class( mtcars )
#2. 이 데이터셋의 행의 개수와 열의 개수 출력
dim( mtcars )
#3. 이 데이터셋 열들의 자료형 출력
str( mtcars )
max.mpg <- max( mtcars$mpg )
rownames( mtcars[ mtcars$mpg == max.mpg, ] ) # 방법 1
rownames( subset( mtcars, mpg == max.mpg ) ) # 방법 2
max.mpg <- max( mtcars$mpg )
rownames( mtcars[ mtcars$mpg == max.mpg, ] )
numberValue <- 1             # camel 표기법
str_value <- 'R Language'    # snake 표기법
booleanvalue <- TRUE         # 일반 표기법
numberValue; print ( numberValue )
str_value; print ( str_value )
booleanvalue; print ( booleanvalue )
cat ( 'Numeric number : ', numberValue, '\n' )
cat ( 'String : ' , str_value, '\n ' )
cat ( 'Boolean value :', booleanvalue , '\n' )
print( '-----------------------------------' )
cat ( 'Numeric number : ', numberValue, '\t',
'String : ' , str_value, '\t',
'Boolean value :', booleanvalue , '\n' )
cat ( 'Numeric number : ', numberValue, '\t',
'String : ' , str_value, '\t',
'Boolean value :', booleanvalue  )
cat ( test )
cat ( 'Numeric number : ', numberValue, '\t',
'String : ' , str_value, '\t',
'Boolean value :', booleanvalue  )
cat ( 'test' )
cat ( 'Numeric number : ', numberValue, '\t',
'String : ' , str_value, '\t',
'Boolean value :', booleanvalue, '\n' )
cat ( 'test' )
inputData <- scan()
class ( inputData )
inputData
inputData <- scan()
class ( inputData )
inputData
inputData <- scan()
inputData
inputData <- scan()
inputData <- scan ( what=character )
inputData <- scan ( what=character() )
class( inputData )
inputData
inputData <- readline( 'Input data -> ' )
class( inputData )
inputData
inputData <- readline( 'Input data -> ' )
class( inputData )
inputData
number1 <- readline( 'Input number1 :' )
result <- number1 + number2
result
number1 <- readline( 'Input number1 :' )
number2 <- readline( 'Input number2 :' )
as.numeric( number1 + number2 )
number1 <- readline( 'Input number1 :' )
result <- number1 + number2
result <- as.numeric( number1 + number2 )
number1 <- readline( 'Input number1 :' )
number2 <- readline( 'Input number2 :' )
result <- as.numeric( number1 + number2 )
result <- as.numeric (number1 + number2)
result <- as.numeric(number1) + as.numeric(number2)
result
number1 <-  readline( 'Input number1 :' )
number2 <-  readline( 'Input number2 :' )
result1 <- as.numeric( number1 ) + as.numeric( number2 )
result2 <- as.numeric( number1 ) - as.numeric( number2 )
result3 <- as.numeric( number1 ) * as.numeric( number2 )
result4 <- as.numeric( number1 ) / as.numeric( number2 )
result5 <- as.numeric( number1 ) %% as.numeric( number2 )
result1 <- as.numeric( number1 ) + as.numeric( number2 )
result1 <- as.numeric( number1 ) + as.numeric( number2 )
result1
result2 <- as.numeric( number1 ) - as.numeric( number2 )
result2
result3 <- as.numeric( number1 ) * as.numeric( number2 )
result3
result4 <- as.numeric( number1 ) / as.numeric( number2 )
result4
result5 <- as.numeric( number1 ) %% as.numeric( number2 )
result5
result1 <- as.numeric( number1 ) + as.numeric( number2 )
result1
result2 <- as.numeric( number1 ) - as.numeric( number2 )
result2
result3 <- as.numeric( number1 ) * as.numeric( number2 )
result3
result4 <- as.numeric( number1 ) / as.numeric( number2 )
result4
result5 <- as.numeric( number1 ) %% as.numeric( number2 )
result5
result <- number1 + number2
setwd( " C:\\workspaceR " )
df <- read.table( file = 'airquality.txt' , header = T )
df
setwd( " C:\\workspaceR " )
df <- read.table( file = "airquality.txt" , header = T )
df
setwd( "C:\\workspaceR" )
df <- read.table( file = "airquality.txt" , header = T )
df
library( rJava )
library( xlsx )
library( rJava )
df.xlsx <- read.xlsx( file = "airquality.xlsx",
sheetIndex = 1,
encoding = "UTF-8" )
setwd( "C:\\workspaceR" )   # 파일 저장 경로 설정
df.xlsx <- read.xlsx( file = "airquality.xlsx",
sheetIndex = 1,
encoding = "UTF-8" )
df.xlsx
class( df.xlsx )
str ( df.xlsx )
head( df.xlsx )
tail( df.xlsx )
score <- c( 76, 55, 24, 7, 99, 73, 23, 47, 60, 34 )
which ( score == 99 )       # 조건에 만족하는 위치의 index
which ( score >= 55 )
max ( score )
which.max ( score )         # 최고값의 index
min ( score )
which.min ( score )         # 최저값의 index
idx <-  which ( score >= 55 )
score [ idx ] <- 47
score
idx <- which ( df.xlsx[ , 1:2] == "NA", arr.ind =  TRUE )
idx                #arr.ind = TRUE : 해당 조건의 행/열 값을 확인할때
setwd( "C:\\workspaceR" )
df.txt <- read.table( file = "airquality.txt",
header = T,
encoding = "UTF-8" )
df.txt
setwd( "C:\\workspaceR" )
df.txt <- read.table( file = "airquality.txt",
header = T,
encoding = "UTF-8" )
df.txt
df.txt <- read.table( file = "airquality.txt",
header = F,
encoding = "UTF-8" )
df.txt
df.txt <- read.table( file = "airquality.txt",
header = T,
encoding = "UTF-8" )
df.txt
favorite <- c( 'WINTER', 'SUMMER', 'SPRING',
'SUMMER', 'SUMMER', 'FALL',
'FALL', 'SUMMER', 'SPRING', 'SPRING')
favorite
class( favorite )
str( favorite )
dim( favorite )
table( favorite )
table ( favorite ) / length( favorite )
ds <- table( favorite )
ds <- table( favorite )
ds
class( ds )
str( ds )
dim( ds )
barplot( ds, main = ' favorite season' )
ds.new <- ds[ c( 2,3,1,4)]
ds.new
barplot( ds.new, main = 'favorite season' )
pie( ds, main = 'favorite season' )
pie( ds.new, main = 'favorite season' )
pie( ds, main = 'favorite season' )
pie( ds.new, main = 'favorite season' )
pie( ds, main = 'favorite season' )
pie( ds.new, main = 'favorite season' )
favorite.color <- c(2,3,2,1,1,2,2,
1,3,2,1,3,2,1,2 )
ds <- table( favorite.color )
ds
barplot( ds, main = ' favorite season' )
colors <- c( 'green', 'red', 'blue' )
names( ds ) <- colors;
ds
barplot( ds, main = 'favorite season',
col = colors )
pie ( ds, main = 'favorite season',
col = colors )
barplot( ds, main = ' favorite season' )
favorite.color <- c(2,3,2,1,1,2,2,
1,3,2,1,3,2,1,2 )
ds <- table( favorite.color )
ds
barplot( ds, main = ' favorite season' )
colors <- c( 'green', 'red', 'blue' )
ds <- table( favorite.color )
ds
barplot( ds, main = ' favorite season' )
colors <- c( 'green', 'red', 'blue' )
barplot( ds, main = ' favorite season' )
colors <- c( 'green', 'red', 'blue' )
names( ds ) <- colors;
ds
barplot( ds, main = 'favorite season',
col = colors )
pie ( ds, main = 'favorite season',
col = colors )
weight <- c( 60, 62, 64, 65, 68, 69 )
weight
weight.heavy <- c( weight, 120 )
weight.heavy
mean ( weight )
mean ( weight.heavy )
median( weight )
median( weight.heavy )
mean ( weight, trim = 0.2 )      # trim 상하위 몇프로 짤라낼거냐
mean ( weight.heavy, trim = 0.2  )
quantile( weight.heavy )
quantile( weight.heavy, (0:10) / (10) )
summary( weight.heavy )
var( weight )
sd ( weight )
range( weight )
diff( range( weight ) )
class( cars )
str( cars )
dist <- cars[ , 2 ]
dist
boxplot.stats( dist )
hist( dist, main = "Histogram for 제동거리 ",
xlab = "제동거리", ylab = "빈도수" ,
border = "blue", col = "green",
las = 2, breaks = 5 )
boxplot( dist, main = "자동차 제동거리" )
boxplot( dist, main = "자동차 제동거리" )
boxplot.stats( dist )
boxplot.stats( dist )$stats # 정상범위 사분위수
boxplot.stats( dist )$n     # 관측치 수
boxplot.stats( dist )$conf  # 중앙값 신뢰구간
boxplot.stats( dist )$out   # 특이값 (이상치) 목록
boxplot( Petal.Length~Speices, data = iris,
main = '품종별 꽃받침 길이' )
boxplot( Petal.Length~Species, data = iris,
main = '품종별 꽃잎 길이' )
str( iris )
boxplot( iris$Petal.Length~iris$Species,
main = '품종별 꽃잎 길이' )
boxplot( Petal.Length~Species, data = iris,
main = '품종별 꽃잎 길이' )
boxplot( iris$Petal.Length~iris$Species,
main = '품종별 꽃잎 길이' )
par (mfrow = c (1,3) )  # 1 X 3 가상화면 분할
barplot( table( mtcars$carb), main = "C",
xlab =  'carburetors', ylab = 'freq',
col = 'blue' )
barplot( table( mtcars$cyl), main = "Cyl",
xlab =  'cyl', ylab = 'freq',
col = 'red' )
barplot( table( mtcars$gear), main = "g",
xlab =  'gear', ylab = 'freq',
col = 'green' )
par(mfow = c(1,1) )    # 가상화면 분할 헤제
par(mfrow = c(1,1) )
